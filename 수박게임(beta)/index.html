<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>수박 게임 — 지속 접촉 합성판</title>
<style>
  :root{--bg:#f0fdf4;--panel:#fffef6;--accent:#fbbf24}
  html,body{height:100%;margin:0;background:linear-gradient(#e6f7ff,#fff);font-family:Inter,system-ui,Arial}
  .wrap{height:100vh;display:flex;align-items:center;justify-content:center}
  canvas{background:var(--panel);border-radius:12px;box-shadow:0 10px 30px rgba(20,30,50,0.12)}
  .hud{position:fixed;left:16px;top:16px;background:rgba(255,255,255,0.9);padding:10px;border-radius:8px;font-weight:700}
  .controls{position:fixed;right:16px;top:16px;display:flex;gap:8px}
  button{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);cursor:pointer}
  #msg{position:fixed;left:50%;top:14px;transform:translateX(-50%);font-weight:800;color:#b91c1c}
</style>
</head>
<body>
<div class="wrap"><canvas id="c" width="420" height="660"></canvas></div>
<div class="hud">점수: <span id="score">0</span><br>최고: <span id="high">0</span></div>
<div id="msg"></div>
<div class="controls"><button id="startBtn">시작</button><button id="resetBtn">리셋</button></div>

<script>
/*
  Suika-style game — 지속 접촉 기반 합성 구현
  주요:
  - 마우스/터치로 조준 -> 클릭/탭으로 드롭
  - 크기 비례 중력(최대 10배)
  - 서브스텝 물리 + 매 프레임 쌍별 접촉 타이머 누적
  - 접촉시간 >= MERGE_HOLD_TIME 이면 합성 발생
  - 충돌 보정/충돌 응답 포함
  - 안전한 합성 처리, 점수/최고점수 저장
*/

const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const scoreEl = document.getElementById('score'), highEl = document.getElementById('high');
const startBtn = document.getElementById('startBtn'), resetBtn = document.getElementById('resetBtn');
const msgEl = document.getElementById('msg');

let running = false;
let score = 0;
let high = parseInt(localStorage.getItem('suika_high')||'0',10);
highEl.textContent = high;

const SUBSTEPS = 4;
const BASE_GRAV = 0.25;
const MAX_GRAV_MULT = 10;
const RESTITUTION = 0.18;
const FRICTION = 0.98;
const MERGE_HOLD_TIME = 0.12; // seconds of continuous contact required
const MERGE_DISTANCE_FACTOR = 0.85; // distance factor to consider “in contact”

const TYPES = [
  {name:'체리', r:10, color:'#ff3b5c', baseScore:1},
  {name:'딸기', r:16, color:'#ff6b88', baseScore:2},
  {name:'포도', r:22, color:'#9b59b6', baseScore:4},
  {name:'사과', r:30, color:'#ef4444', baseScore:8},
  {name:'레몬', r:40, color:'#fde047', baseScore:16},
  {name:'멜론', r:50, color:'#7dd3a6', baseScore:32},
  {name:'수박', r:64, color:'#16a34a', baseScore:64},
  {name:'파인', r:76, color:'#facc15', baseScore:120},
  {name:'망고', r:90, color:'#f59e0b', baseScore:300},
  {name:'두리안', r:110, color:'#84cc16', baseScore:800}
];

const MIN_R = TYPES[0].r, MAX_R = TYPES[TYPES.length-1].r;
let fruits = [], current = null, pointerX = W/2;
let particles = [];

/* utilities */
const rand = (a,b)=>Math.random()*(b-a)+a;
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const massForR = r => Math.PI * r * r / 1000;
const gravMultForR = r => 1 + ((r - MIN_R) / (MAX_R - MIN_R)) * (MAX_GRAV_MULT - 1);

/* unique id */
let _idCounter = 1;
function nextId(){ return (_idCounter++).toString(); }

/* create fruit object */
function makeFruit(level,x=null,y=null){
  const t = TYPES[level];
  return {
    id: nextId(),
    level,
    r: t.r,
    color: t.color,
    x: x === null ? clamp(pointerX, t.r+8, W - t.r - 8) : x,
    y: y === null ? 120 : y,
    vx: 0, vy: 0,
    mass: massForR(t.r),
    removed: false,
  };
}

/* spawn current to follow pointer */
function spawnCurrent(){
  const idx = Math.random() < 0.9 ? 0 : 1; // mostly small ones
  current = makeFruit(idx);
}

/* particles */
function spawnParticles(x,y,color,n=12){
  for(let i=0;i<n;i++){
    particles.push({x,y,vx:rand(-3,3),vy:rand(-4,1),age:0,life:rand(24,48),s:rand(2,5),color});
  }
}

/* input */
canvas.addEventListener('mousemove', e=>{
  const r = canvas.getBoundingClientRect();
  pointerX = (e.clientX - r.left) * (W / r.width);
  if(current) current.x = clamp(pointerX, current.r+6, W - current.r - 6);
});
canvas.addEventListener('touchmove', e=>{
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  pointerX = (e.touches[0].clientX - r.left) * (W / r.width);
  if(current) current.x = clamp(pointerX, current.r+6, W - current.r - 6);
},{passive:false});

function dropCurrent(){
  if(!running || !current) return;
  current.vx = 0; current.vy = 0;
  fruits.push(current);
  current = null;
  setTimeout(spawnCurrent, 300);
}
canvas.addEventListener('click', dropCurrent);
canvas.addEventListener('touchend', (e)=>{ e.preventDefault(); dropCurrent(); }, {passive:false});
window.addEventListener('keydown', e=>{ if(e.code === 'Space') dropCurrent(); });

/* contact timers map: key "idA|idB" with ids sorted */
const contactTimers = new Map();
function pairKey(a,b){ return a < b ? a + '|' + b : b + '|' + a; }

/* physics step with substeps */
function physicsStep(dt){
  const subDt = dt / SUBSTEPS;
  for(let s=0;s<SUBSTEPS;s++){
    // integrate gravity & velocity
    for(const f of fruits){
      const g = BASE_GRAV * gravMultForR(f.r);
      f.vy += g * subDt * 60; // scaled for feel
      f.x += f.vx * subDt * 60;
      f.y += f.vy * subDt * 60;
      // mild air drag
      f.vx *= 0.999;
      f.vy *= 0.999;
    }

    // wall & floor collisions
    for(const f of fruits){
      if(f.y + f.r > H){
        f.y = H - f.r;
        f.vy = -Math.abs(f.vy) * RESTITUTION;
        f.vx *= FRICTION;
        if(Math.abs(f.vy) < 0.4) f.vy = 0;
      }
      if(f.x - f.r < 0){
        f.x = f.r; f.vx = Math.abs(f.vx) * RESTITUTION;
      }
      if(f.x + f.r > W){
        f.x = W - f.r; f.vx = -Math.abs(f.vx) * RESTITUTION;
      }
    }

    // pairwise collisions: separation + impulse + contact timers
    // first mark collisions for this substep
    const collidedPairsThisStep = new Set();
    for(let i=0;i<fruits.length;i++){
      for(let j=i+1;j<fruits.length;j++){
        const A = fruits[i], B = fruits[j];
        if(A.removed || B.removed) continue;
        const dx = A.x - B.x, dy = A.y - B.y;
        const dist = Math.hypot(dx,dy) || 0.0001;
        const minDist = A.r + B.r;
        if(dist < minDist){
          // separation
          const overlap = minDist - dist;
          const nx = dx / dist, ny = dy / dist;
          const totalMass = A.mass + B.mass;
          const ax = nx * overlap;
          const ay = ny * overlap;
          A.x += ax * (B.mass / totalMass);
          A.y += ay * (B.mass / totalMass);
          B.x -= ax * (A.mass / totalMass);
          B.y -= ay * (A.mass / totalMass);

          // relative velocity along normal
          const relVx = B.vx - A.vx, relVy = B.vy - A.vy;
          const relAlong = relVx * nx + relVy * ny;
          // apply impulse only if closing
          if(relAlong > 0){
            const e = RESTITUTION;
            const jimp = (-(1+e) * relAlong) / (1/A.mass + 1/B.mass);
            const ix = jimp * nx, iy = jimp * ny;
            A.vx -= ix / A.mass; A.vy -= iy / A.mass;
            B.vx += ix / B.mass; B.vy += iy / B.mass;
          }
          // friction-like tangential damping (small)
          const tx = -ny, ty = nx;
          const relTan = relVx * tx + relVy * ty;
          const tanImp = relTan * 0.02;
          A.vx -= (tanImp * tx) / A.mass; A.vy -= (tanImp * ty) / A.mass;
          B.vx += (tanImp * tx) / B.mass; B.vy += (tanImp * ty) / B.mass;

          // register contact for merge detection
          const key = pairKey(A.id, B.id);
          collidedPairsThisStep.add(key);
        }
      }
    }

    // update contactTimers map: increase for present pairs, reset for missing pairs
    // accumulate subDt*60 scale to be frame-time consistent (we'll use real-time below)
    // We'll accumulate actual seconds: subDt (seconds)
    // First, mark seen pairs
    const seenKeys = new Set();
    for(const key of collidedPairsThisStep) seenKeys.add(key);
    // increment for seen
    for(const key of seenKeys){
      const prev = contactTimers.get(key) || 0;
      contactTimers.set(key, prev + subDt);
    }
    // decrement/reset for keys not seen (remove if absent)
    // we must remove keys not in seenKeys
    for(const key of Array.from(contactTimers.keys())){
      if(!seenKeys.has(key)){
        contactTimers.delete(key);
      }
    }

    // minor velocity damping each substep
    for(const f of fruits){
      f.vx *= 0.999;
      f.vy *= 0.999;
    }
  } // end substep loop
}

/* merge handling: check timers and perform merges */
function handleMerges(){
  // gather merge pairs whose timer >= threshold and still both exist
  const pairsToMerge = [];
  for(const [key, tval] of contactTimers.entries()){
    if(tval >= MERGE_HOLD_TIME){
      const ids = key.split('|');
      const A = fruits.find(x => x.id === ids[0]);
      const B = fruits.find(x => x.id === ids[1]);
      if(!A || !B) { contactTimers.delete(key); continue; }
      if(A.level === B.level){
        // ensure still physically overlapping enough (safety)
        const dx = A.x - B.x, dy = A.y - B.y, dist = Math.hypot(dx,dy);
        if(dist < MERGE_DISTANCE_FACTOR * (A.r + B.r)){
          pairsToMerge.push([A,B]);
        } else {
          // if separated, reset timer
          contactTimers.delete(key);
        }
      } else {
        contactTimers.delete(key);
      }
    }
  }

  if(pairsToMerge.length === 0) return;

  // To avoid double merges/conflicts, mark ids used
  const used = new Set();
  for(const [A,B] of pairsToMerge){
    if(used.has(A.id) || used.has(B.id)) continue;
    used.add(A.id); used.add(B.id);
    // compute spawn level
    const nextLevel = Math.min(A.level + 1, TYPES.length - 1);
    const nx = (A.x + B.x) / 2;
    const ny = (A.y + B.y) / 2;
    // momentum conservation (approx)
    const totalMass = A.mass + B.mass;
    const vx = (A.vx * A.mass + B.vx * B.mass) / totalMass;
    const vy = (A.vy * A.mass + B.vy * B.mass) / totalMass - 2; // give slight upward kick
    // mark removed
    A.removed = true; B.removed = true;
    // remove contact timers involving them
    for(const key of Array.from(contactTimers.keys())){
      if(key.includes(A.id) || key.includes(B.id)) contactTimers.delete(key);
    }
    // create merged fruit with preserved momentum
    const merged = makeFruit(nextLevel, nx, ny - 4);
    merged.vx = vx; merged.vy = vy;
    fruits.push(merged);
    spawnParticles(nx, ny, merged.color, 20);
    // score increment
    const gain = TYPES[nextLevel].baseScore * 10;
    score += gain;
    scoreEl.textContent = score;
    if(score > high){ high = score; localStorage.setItem('suika_high', high.toString()); highEl.textContent = high; }
  }

  // filter removed fruits
  fruits = fruits.filter(f => !f.removed);
}

/* render */
function render(){
  ctx.clearRect(0,0,W,H);
  // background
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#e7fbff'); g.addColorStop(1,'#fffef0');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // floor
  ctx.fillStyle = "#eaeaea"; ctx.fillRect(0,H-12,W,12);

  // fruits
  for(const f of fruits){
    // shadow
    ctx.beginPath();
    ctx.ellipse(f.x, f.y + f.r*0.6, f.r*0.9, f.r*0.35, 0, 0, Math.PI*2);
    ctx.fillStyle = "rgba(0,0,0,0.06)"; ctx.fill();

    ctx.beginPath();
    ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
    ctx.fillStyle = f.color; ctx.fill();
    ctx.lineWidth = 2; ctx.strokeStyle = "rgba(255,255,255,0.35)"; ctx.stroke();

    // number label
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.font = Math.max(10, Math.floor(f.r/1.6)) + "px sans-serif";
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText((f.level+1).toString(), f.x, f.y);
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i]; p.age++;
    p.x += p.vx; p.y += p.vy; p.vy += 0.12;
    ctx.globalAlpha = 1 - p.age / p.life;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.s,0,Math.PI*2); ctx.fillStyle = p.color; ctx.fill();
    ctx.globalAlpha = 1;
    if(p.age >= p.life) particles.splice(i,1);
  }

  // current (follow pointer)
  if(current){
    ctx.beginPath(); ctx.arc(current.x,current.y,current.r,0,Math.PI*2);
    ctx.fillStyle = current.color; ctx.globalAlpha = 0.9; ctx.fill(); ctx.globalAlpha = 1;
    ctx.strokeStyle = "#fff8"; ctx.lineWidth = 1; ctx.stroke();
    ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.font = Math.max(10,Math.floor(current.r/1.6)) + "px sans-serif";
    ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText((current.level+1).toString(), current.x, current.y);
  }
}

/* game over check */
function checkGameOver(){
  for(const f of fruits){
    if(f.y - f.r < 0){
      running = false;
      msgEl.textContent = `게임 오버! 점수: ${score}`;
      setTimeout(()=>{ msgEl.textContent = ""; startBtn.disabled = false; }, 1600);
      return true;
    }
  }
  return false;
}

/* main loop */
let lastTime = performance.now();
function loop(now){
  if(!running) return;
  const dt = Math.min( (now - lastTime) / 1000, 1/20 );
  lastTime = now;

  physicsStep(dt);
  handleMerges();
  render();
  if(!checkGameOver()) requestAnimationFrame(loop);
}

/* start/reset */
function startGame(){
  fruits = []; particles = []; contactTimers.clear();
  current = null; score = 0; scoreEl.textContent = 0; msgEl.textContent = "";
  spawnCurrent(); running = true; startBtn.disabled = true; lastTime = performance.now();
  requestAnimationFrame(loop);
}
function resetGame(){
  running = false; fruits = []; particles = []; current = null; score = 0;
  scoreEl.textContent = 0; msgEl.textContent = ""; startBtn.disabled = false;
  high = parseInt(localStorage.getItem('suika_high')||'0',10); highEl.textContent = high;
}

/* spawn initial current */
function spawnCurrent(){
  const idx = Math.random() < 0.9 ? 0 : 1;
  current = makeFruit(idx);
}

/* UI */
startBtn.addEventListener('click', startGame);
resetBtn.addEventListener('click', resetGame);
msgEl.textContent = "클릭/탭으로 드롭 — 마우스로 좌우 조준";
setTimeout(()=> msgEl.textContent = "", 2200);

</script>
</body>
</html>
