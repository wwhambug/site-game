<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metal Slug Mobile</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            width: 100%;
            max-width: 500px;
            height: 100vh;
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #000, #1a1a1a, #000);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeOut 2s ease-in-out forwards;
            animation-delay: 0.5s;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; pointer-events: none; }
        }

        .loading-screen h1 {
            color: #ff6b35;
            font-size: 2.5em;
            text-shadow: 3px 3px 0px #000, -1px -1px 0px #ffb700;
            margin-bottom: 30px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .loading-bar-container {
            width: 200px;
            height: 20px;
            border: 2px solid #ff6b35;
            background: #000;
            position: relative;
            overflow: hidden;
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b35, #ffb700);
            width: 0%;
            animation: loading 2s ease-in-out forwards;
            box-shadow: 0 0 10px #ff6b35;
        }

        @keyframes loading {
            0% { width: 0%; }
            100% { width: 100%; }
        }

        .loading-text {
            color: #ffb700;
            margin-top: 20px;
            font-size: 1.2em;
            font-weight: bold;
        }

        .game-screen {
            flex: 1;
            background: linear-gradient(180deg, #87ceeb 0%, #e0f6ff 100%);
            position: relative;
            overflow: hidden;
        }

        .game-area {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .hud {
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #ffb700;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #ff6b35;
        }

        .score {
            font-size: 1.2em;
            text-shadow: 2px 2px 4px #000;
        }

        .distance {
            font-size: 1.2em;
            text-shadow: 2px 2px 4px #000;
        }

        .controls {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            border-top: 2px solid #ff6b35;
        }

        .btn {
            padding: 15px;
            background: linear-gradient(135deg, #ff6b35, #ffb700);
            border: 3px solid #000;
            color: #000;
            font-weight: bold;
            font-size: 1em;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.1s;
            text-shadow: 1px 1px 0px rgba(255, 255, 255, 0.5);
            box-shadow: 4px 4px 0px #000;
            user-select: none;
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px #000;
        }

        .btn:hover {
            background: linear-gradient(135deg, #ffb700, #ff6b35);
        }

        .btn-left { grid-column: 1; }
        .btn-jump { grid-column: 2; }
        .btn-shoot { grid-column: 3; background: linear-gradient(135deg, #ff4444, #ff6b6b); }
        .btn-shoot:hover { background: linear-gradient(135deg, #ff6b6b, #ff4444); }
        .btn-right { grid-column: 1; }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }

        .game-over-screen.show {
            display: flex;
        }

        .game-over-text {
            font-size: 3em;
            color: #ff6b35;
            text-shadow: 3px 3px 0px #000, -1px -1px 0px #ffb700;
            margin-bottom: 20px;
        }

        .final-score {
            font-size: 2em;
            color: #ffb700;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px #000;
        }

        .restart-btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            border: 3px solid #000;
            color: #000;
            font-weight: bold;
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 4px 4px 0px #000;
        }

        .restart-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px #000;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="loading-screen">
            <h1>METAL SLUG</h1>
            <div class="loading-bar-container">
                <div class="loading-bar"></div>
            </div>
            <div class="loading-text">LOADING...</div>
        </div>

        <div class="hud">
            <div class="score">SCORE: <span id="scoreValue">0</span></div>
            <div class="distance">DISTANCE: <span id="distanceValue">0</span>m</div>
        </div>

        <div class="game-screen">
            <div class="game-area" id="gameArea">
                <canvas id="gameCanvas"></canvas>
                <div id="gameOverScreen" class="game-over-screen">
                    <div class="game-over-text">GAME OVER</div>
                    <div class="final-score">FINAL SCORE: <span id="finalScore">0</span></div>
                    <button class="restart-btn" onclick="location.reload()">RESTART</button>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-left" id="leftBtn">◀ LEFT</button>
            <button class="btn btn-jump" id="jumpBtn">⬆ JUMP</button>
            <button class="btn btn-shoot" id="shootBtn">SHOOT</button>
            <button class="btn btn-right" id="rightBtn">RIGHT ▶</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameArea = document.getElementById('gameArea');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const scoreValue = document.getElementById('scoreValue');
        const distanceValue = document.getElementById('distanceValue');
        const finalScore = document.getElementById('finalScore');

        canvas.width = gameArea.offsetWidth;
        canvas.height = gameArea.offsetHeight;

        // 게임 상태
        let playerX = 100;
        let playerY = canvas.height - 100;
        let playerVelX = 0;
        let playerVelY = 0;
        let score = 0;
        let gameOver = false;
        let shootDirection = 1;
        let distance = 0;
        let onGround = false;
        
        const gravity = 0.6;
        const jumpPower = -12;
        const maxVelX = 6;
        const acceleration = 0.4;
        const maxVelY = 12;

        let platforms = [];
        let enemies = [];
        let bullets = [];
        let warnings = [];
        let cameraX = 0;

        const keys = { left: false, right: false, jump: false };

        // 지면 높이
        const groundLevel = canvas.height - 50;

        // 플랫폼 생성
        function generatePlatforms() {
            platforms = [];
            
            // 기본 지면
            platforms.push({
                x: -500,
                y: groundLevel,
                width: canvas.width * 20,
                height: 50,
                type: 'ground'
            });

            // 지형물들 (지면 위에만)
            for (let x = 0; x < canvas.width * 10; x += 150) {
                if (Math.random() < 0.4) {
                    const type = Math.random() < 0.5 ? 'mountain' : 'bridge';
                    let width = 60;
                    if (type === 'bridge') width = 100;
                    
                    platforms.push({
                        x: x,
                        y: groundLevel - 40,
                        width: width,
                        height: 40,
                        type: type
                    });
                }
            }
        }

        function createNewPlatforms() {
            const maxX = Math.max(...platforms.filter(p => p.type !== 'ground').map(p => p.x));

            for (let x = maxX + 150; x < maxX + canvas.width + 500; x += 150) {
                if (Math.random() < 0.4) {
                    const type = Math.random() < 0.5 ? 'mountain' : 'bridge';
                    let width = 60;
                    if (type === 'bridge') width = 100;
                    
                    platforms.push({
                        x: x,
                        y: groundLevel - 40,
                        width: width,
                        height: 40,
                        type: type
                    });
                }
            }
        }

        function drawPlatforms() {
            platforms.forEach(p => {
                const screenX = p.x - cameraX;

                if (screenX < canvas.width + 50 && screenX + p.width > -50) {
                    if (p.type === 'mountain') {
                        ctx.fillStyle = '#696969';
                        ctx.beginPath();
                        ctx.moveTo(screenX, p.y + p.height);
                        ctx.lineTo(screenX + p.width / 2, p.y);
                        ctx.lineTo(screenX + p.width, p.y + p.height);
                        ctx.fill();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else if (p.type === 'ground') {
                        ctx.fillStyle = '#90EE90';
                        ctx.fillRect(screenX, p.y, p.width, p.height);
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(screenX, p.y, p.width, p.height);
                    } else if (p.type === 'bridge') {
                        ctx.fillStyle = '#A0522D';
                        ctx.fillRect(screenX, p.y, p.width, p.height);
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(screenX, p.y, p.width, p.height);
                    }
                }
            });
        }

        function drawPlayer() {
            const screenX = playerX - cameraX;
            const screenY = playerY;

            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(screenX, screenY, 35, 40);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(screenX, screenY, 35, 40);

            // 총구
            if (shootDirection > 0) {
                ctx.fillStyle = '#333';
                ctx.fillRect(screenX + 35, screenY + 15, 10, 4);
            } else {
                ctx.fillStyle = '#333';
                ctx.fillRect(screenX - 10, screenY + 15, 10, 4);
            }
        }

        function drawWarnings() {
            warnings.forEach(w => {
                const screenX = w.x - cameraX;
                const screenY = w.y;

                ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
                ctx.fillRect(screenX, screenY, 30, 40);
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, 30, 40);
            });
        }

        function drawEnemies() {
            enemies.forEach(e => {
                const screenX = e.x - cameraX;
                const screenY = e.y;

                if (screenX < canvas.width + 50 && screenX + 30 > -50) {
                    ctx.fillStyle = '#4444ff';
                    ctx.fillRect(screenX, screenY, 30, 40);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, screenY, 30, 40);
                }
            });
        }

        function drawBullets() {
            bullets.forEach(b => {
                const screenX = b.x - cameraX;
                const screenY = b.y;

                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(screenX, screenY, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function updatePlayer() {
            // 좌우 이동
            if (keys.left) {
                playerVelX = Math.max(playerVelX - acceleration, -maxVelX);
                shootDirection = -1;
            } else if (keys.right) {
                playerVelX = Math.min(playerVelX + acceleration, maxVelX);
                shootDirection = 1;
            } else {
                playerVelX *= 0.85;
            }

            // 중력
            playerVelY += gravity;
            playerVelY = Math.min(playerVelY, maxVelY);

            playerY += playerVelY;
            playerX += playerVelX;

            // 플랫폼 충돌
            onGround = false;
            platforms.forEach(p => {
                if (playerVelY > 0 &&
                    playerY + 40 <= p.y + 5 &&
                    playerY + 40 + playerVelY >= p.y &&
                    playerX + 35 > p.x &&
                    playerX < p.x + p.width) {
                    playerVelY = 0;
                    playerY = p.y - 40;
                    onGround = true;
                }
            });

            // 점프
            if (keys.jump && onGround) {
                playerVelY = jumpPower;
                onGround = false;
            }

            // 카메라
            cameraX = Math.max(0, playerX - 100);

            // 거리
            distance = Math.floor(playerX / 100);
            distanceValue.textContent = distance;

            // 새 플랫폼 생성
            if (playerX > Math.max(...platforms.filter(p => p.type !== 'ground').map(p => p.x)) - canvas.width) {
                createNewPlatforms();
            }

            // 적과 충돌
            enemies.forEach(e => {
                if (playerX + 35 > e.x &&
                    playerX < e.x + 30 &&
                    playerY + 40 > e.y &&
                    playerY < e.y + 40) {
                    endGame();
                }
            });

            // 화면 아래로 떨어지면 게임 오버
            if (playerY > canvas.height) {
                endGame();
            }
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.x += b.velX;

                // 적과 충돌
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (b.x > e.x && b.x < e.x + 30 &&
                        b.y > e.y && b.y < e.y + 40) {
                        enemies.splice(j, 1);
                        score += 100;
                        scoreValue.textContent = score;
                        hit = true;
                        break;
                    }
                }

                if (hit || b.x > cameraX + canvas.width + 100 || b.x < cameraX - 100) {
                    bullets.splice(i, 1);
                }
            }
        }

        function updateEnemies() {
            // 적 업데이트
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                
                // 중력
                e.velY += gravity;
                e.velY = Math.min(e.velY, maxVelY);
                
                e.y += e.velY;
                e.x += e.velX;

                // 플랫폼 충돌
                let onEnemyGround = false;
                platforms.forEach(p => {
                    if (e.velY > 0 &&
                        e.y + 40 <= p.y + 5 &&
                        e.y + 40 + e.velY >= p.y &&
                        e.x + 30 > p.x &&
                        e.x < p.x + p.width) {
                        e.velY = 0;
                        e.y = p.y - 40;
                        onEnemyGround = true;
                    }
                });

                // 화면 밖으로 나가면 제거
                if (e.x < cameraX - 100 || e.x > cameraX + canvas.width + 100 || e.y > canvas.height) {
                    if (e.x < cameraX - 100) {
                        endGame();
                    }
                    enemies.splice(i, 1);
                }
            }

            // 경고 업데이트
            for (let i = warnings.length - 1; i >= 0; i--) {
                const w = warnings[i];
                w.time--;

                if (w.time <= 0) {
                    const enemy = {
                        x: w.x,
                        y: w.y,
                        velX: (Math.random() > 0.5 ? 2 : -2),
                        velY: 0
                    };
                    enemies.push(enemy);
                    warnings.splice(i, 1);
                }
            }
        }

        function spawnEnemy() {
            if (gameOver) return;

            const spawnX = cameraX + canvas.width + 50;
            const spawnY = groundLevel - 80;

            warnings.push({
                x: spawnX,
                y: spawnY,
                time: 60
            });
        }

        function shoot() {
            if (gameOver) return;

            bullets.push({
                x: playerX + (shootDirection > 0 ? 35 : 0),
                y: playerY + 15,
                velX: shootDirection * 8
            });
        }

        function endGame() {
            gameOver = true;
            gameOverScreen.classList.add('show');
            finalScore.textContent = score;
        }

        function gameLoop() {
            // 배경
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawPlatforms();
            drawWarnings();
            drawEnemies();
            drawBullets();
            drawPlayer();

            updatePlayer();
            updateBullets();
            updateEnemies();

            // 적 생성
            if (Math.random() < 0.008 && enemies.length + warnings.length < 4) {
                spawnEnemy();
            }

            requestAnimationFrame(gameLoop);
        }

        // 버튼 이벤트
        document.getElementById('leftBtn').addEventListener('mousedown', () => keys.left = true);
        document.getElementById('leftBtn').addEventListener('mouseup', () => keys.left = false);
        document.getElementById('leftBtn').addEventListener('touchstart', (e) => { e.preventDefault(); keys.left = true; });
        document.getElementById('leftBtn').addEventListener('touchend', (e) => { e.preventDefault(
