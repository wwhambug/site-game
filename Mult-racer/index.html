<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Pixel Racer — Multiplayer (Single File)</title>
  <style>
    html,body{height:100%;margin:0;background:#071029;display:flex;align-items:center;justify-content:center}
    #wrap{width:100%;max-width:720px;aspect-ratio:9/16;position:relative}
    canvas{width:100%;height:100%;display:block;background:#0f2030;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.6)}
    .ui{position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none}
    .hud{position:absolute;top:8px;left:8px;color:#fff;font-family:monospace;font-size:14px;pointer-events:auto}
    .controls{position:absolute;bottom:12px;left:8px;right:8px;display:flex;justify-content:space-between;pointer-events:none}
    .btn{width:72px;height:72px;border-radius:12px;background:linear-gradient(180deg,#ffffff10,#00000020);backdrop-filter:blur(4px);display:flex;align-items:center;justify-content:center;font-weight:700;color:#fff;pointer-events:auto;user-select:none}
    .btn.small{width:56px;height:56px}
    .left-controls{display:flex;gap:8px}
    .right-controls{display:flex;gap:8px}
    .overlay{position:absolute;right:8px;top:8px;display:flex;flex-direction:column;gap:8px}
    .panel{background:#ffffff08;padding:8px;border-radius:8px;color:#fff;font-family:monospace;pointer-events:auto}
    input[type=text]{padding:6px;border-radius:6px;border:1px solid #ffffff22;background:#00000044;color:#fff}
    button.primary{background:#4f46e5;border:none;padding:8px 12px;border-radius:8px;color:#fff;cursor:pointer}

    /* modal for name entry */
    #modal{position:absolute;inset:0;background:linear-gradient(180deg,rgba(0,0,0,.6),rgba(0,0,0,.75));display:flex;align-items:center;justify-content:center;z-index:20}
    .modal-card{background:#081827;padding:20px;border-radius:12px;color:#fff;min-width:240px;text-align:center}
    .modal-card input{width:100%;margin-top:8px}

    @media (min-width:720px){.btn{width:84px;height:84px}}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="360" height="640"></canvas>

    <div class="ui">
      <div class="hud" id="hud">Score: 0</div>

      <div class="overlay">
        <div class="panel" id="highscores">Highscores: —</div>
        <div class="panel">
          <label>이름: <input id="name" type="text" maxlength="10" placeholder="익명" /></label>
          <button id="saveBtn" class="primary">점수전송</button>
        </div>
      </div>

      <div class="controls">
        <div class="left-controls">
          <div id="leftBtn" class="btn">◀</div>
          <div id="rightBtn" class="btn">▶</div>
        </div>
        <div class="right-controls">
          <div id="accelBtn" class="btn small">▲</div>
          <div id="brakeBtn" class="btn small">▼</div>
        </div>
      </div>
    </div>

    <div id="modal">
      <div class="modal-card">
        <h3>닉네임을 입력하세요</h3>
        <input id="startName" maxlength="12" placeholder="플레이어" />
        <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
          <button id="startBtn" class="primary">시작</button>
        </div>
      </div>
    </div>

  </div>

  <!-- Supabase JS -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js/dist/umd/supabase.min.js"></script>

  <script>
  // ---------- CONFIG ----------
  const SUPABASE_URL = 'https://falkihlzhrqugefjkqvt.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZhbGtpaGx6aHJxdWdlZmprcXZ0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA4NzY3NTIsImV4cCI6MjA3NjQ1Mjc1Mn0.XS7cqVEPxHdA-JP25WWj75tUHhJEw_A8Zj_Q4wKRjq8';

  // ---------- Supabase init ----------
  const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // ---------- Game (single-file pixel racer) ----------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  const baseW = canvas.width, baseH = canvas.height;
  let scale = 1;
  function fitCanvas(){ const rect = canvas.getBoundingClientRect(); scale = rect.width / baseW; }
  window.addEventListener('resize', fitCanvas); fitCanvas();

  // Player / game state
  let running = true;
  let score = 0;
  const player = {x: baseW/2, y: baseH - 80, w: 24, h: 36, vx:0, speed:2.0};
  const road = {x:40, w:baseW-80};
  let obstacles = [];
  let tick = 0;

  // Multiplayer state
  const localId = crypto.randomUUID();
  let localName = localStorage.getItem('pixel-racer-name') || '';
  const remotePlayers = new Map(); // id -> {name,x,y,speed,updated_at,color}
  const colors = ['#ff6666','#66b3ff','#ffd166','#8aff8a','#c39cff','#ffa8d6'];

  // Controls
  const controls = {left:false,right:false,accel:false,brake:false};
  function bindControls(){
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft')controls.left=true; if(e.key==='ArrowRight')controls.right=true; if(e.key==='ArrowUp')controls.accel=true; if(e.key==='ArrowDown')controls.brake=true; });
    window.addEventListener('keyup', e=>{ if(e.key==='ArrowLeft')controls.left=false; if(e.key==='ArrowRight')controls.right=false; if(e.key==='ArrowUp')controls.accel=false; if(e.key==='ArrowDown')controls.brake=false; });
    ['leftBtn','rightBtn','accelBtn','brakeBtn'].forEach(id=>{
      const el = document.getElementById(id);
      if(!el) return;
      el.addEventListener('touchstart', e=>{ e.preventDefault(); if(id==='leftBtn')controls.left=true; if(id==='rightBtn')controls.right=true; if(id==='accelBtn')controls.accel=true; if(id==='brakeBtn')controls.brake=true; });
      el.addEventListener('touchend', e=>{ e.preventDefault(); if(id==='leftBtn')controls.left=false; if(id==='rightBtn')controls.right=false; if(id==='accelBtn')controls.accel=false; if(id==='brakeBtn')controls.brake=false; });
      el.addEventListener('mousedown', e=>{ e.preventDefault(); if(id==='leftBtn')controls.left=true; if(id==='rightBtn')controls.right=true; if(id==='accelBtn')controls.accel=true; if(id==='brakeBtn')controls.brake=true; });
      el.addEventListener('mouseup', e=>{ e.preventDefault(); if(id==='leftBtn')controls.left=false; if(id==='rightBtn')controls.right=false; if(id==='accelBtn')controls.accel=false; if(id==='brakeBtn')controls.brake=false; });
    });
    // touch swipe steer
    let startX = null;
    canvas.addEventListener('touchstart', e=>{ startX = e.touches[0].clientX; });
    canvas.addEventListener('touchmove', e=>{ if(startX==null) return; const dx = e.touches[0].clientX - startX; controls.left = dx < -10; controls.right = dx > 10; });
    canvas.addEventListener('touchend', e=>{ startX = null; controls.left=false; controls.right=false; });
  }
  bindControls();

  function spawnObstacle(){
    const laneCount = 3; const laneW = road.w / laneCount; const laneIndex = Math.floor(Math.random()*laneCount);
    const w = 28 + Math.floor(Math.random()*20); const h = 36 + Math.floor(Math.random()*20);
    const x = road.x + laneIndex*laneW + (laneW - w)/2; obstacles.push({x,y:-h, w,h, vy:2 + Math.random()*2});
  }
  function resetGame(){ obstacles=[]; score=0; tick=0; player.x=baseW/2; player.vx=0; running=true; }
  function rectIntersect(x1,y1,w1,h1,x2,y2,w2,h2){ return !(x1+w1 < x2 || x2+w2 < x1 || y1+h1 < y2 || y2+h2 < y1); }

  function update(dt){
    tick++;
    if(tick % Math.max(40,30 - Math.floor(score/100)) === 0) spawnObstacle();
    if(controls.left) player.vx -= 0.15; if(controls.right) player.vx += 0.15; if(!controls.left && !controls.right) player.vx *= 0.92;
    if(controls.accel) player.speed = Math.min(6, player.speed + 0.05); else player.speed = Math.max(2, player.speed - 0.02);
    if(controls.brake) player.speed = Math.max(1, player.speed - 0.2);
    player.x += player.vx; const halfW = player.w/2; player.x = Math.max(road.x + halfW, Math.min(road.x + road.w - halfW, player.x));
    for(let o of obstacles){ o.y += o.vy * (player.speed/3); }
    obstacles = obstacles.filter(o=>o.y < baseH + 100);
    for(let o of obstacles){ if(rectIntersect(player.x - player.w/2, player.y - player.h/2, player.w, player.h, o.x, o.y, o.w, o.h)){ running=false; } }
    score += Math.floor(player.speed * 0.2);
  }

  function draw(){
    ctx.fillStyle = '#0f2030'; ctx.fillRect(0,0,baseW,baseH);
    ctx.fillStyle = '#213245'; ctx.fillRect(road.x,0,road.w,baseH);
    ctx.fillStyle = '#0b1320'; ctx.fillRect(road.x-6,0,6,baseH); ctx.fillRect(road.x+road.w,0,6,baseH);
    ctx.fillStyle = '#f5f7fb'; const dashH = 24; const gap = 18;
    for(let y= -((tick* (player.speed/3))% (dashH+gap)); y<baseH; y+=dashH+gap){ ctx.fillRect(baseW/2 - 4, y, 8, dashH); }
    // draw other players
    for(const [id,p] of remotePlayers.entries()){
      if(id === localId) continue;
      drawCar(p.x - p.w/2, p.y - p.h/2, p.w, p.h, false, p.color);
      // name tag
      ctx.font = '10px monospace'; ctx.fillStyle = '#fff'; ctx.fillText(p.name || 'player', Math.round(p.x - p.w/2), Math.round(p.y - p.h/2 - 6));
    }
    drawCar(player.x - player.w/2, player.y - player.h/2, player.w, player.h, true, '#ff6666');
    for(let o of obstacles) drawCar(o.x, o.y, o.w, o.h, false);
    document.getElementById('hud').innerText = `Score: ${score}`;
  }

  function drawCar(x,y,w,h,isPlayer,color){ const px = Math.round(x), py = Math.round(y), pw = Math.round(w), ph = Math.round(h); ctx.fillStyle = color || (isPlayer? '#ff6666' : '#66b3ff'); roundRect(ctx, px, py, pw, ph, 4); ctx.fillStyle = '#ffffff40'; ctx.fillRect(px + pw*0.15, py + ph*0.1, pw*0.45, ph*0.3); ctx.fillRect(px + pw*0.56, py + ph*0.1, pw*0.25, ph*0.3); ctx.fillStyle = '#111'; ctx.fillRect(px + 4, py + ph - 6, 8, 6); ctx.fillRect(px + pw - 12, py + ph -6, 8, 6); }
  function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); ctx.fill(); }

  let last = performance.now(); function loop(now){ const dt = (now - last)/1000; last = now; if(running) update(dt); draw(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);
  canvas.addEventListener('click', ()=>{ if(!running) resetGame(); });

  // ---------- Scores (local + supabase) ----------
  const highEl = document.getElementById('highscores');
  function saveLocalScore(name,scoreVal){ const list = JSON.parse(localStorage.getItem('pixel-racer-scores')||'[]'); list.push({name,score:scoreVal,at:new Date().toISOString()}); list.sort((a,b)=>b.score-a.score); localStorage.setItem('pixel-racer-scores', JSON.stringify(list.slice(0,10))); renderLocalHighscores(); }
  function renderLocalHighscores(){ const list = JSON.parse(localStorage.getItem('pixel-racer-scores')||'[]'); highEl.innerText = 'Highscores (local):
' + (list.length? list.map((s,i)=>`${i+1}. ${s.name} - ${s.score}`).join('
') : '—'); }
  renderLocalHighscores();

  async function saveRemoteScore(name,scoreVal){ try{ const { data, error } = await supabaseClient.from('scores').insert([{ name, score: scoreVal }]); if(error) throw error; await fetchTopRemote(); return true; }catch(err){ console.warn('supabase save error',err); alert('원격 저장 실패'); return false; } }
  async function fetchTopRemote(){ try{ const { data, error } = await supabaseClient.from('scores').select('name,score').order('score',{ ascending:false }).limit(5); if(error) throw error; if(data && data.length){ highEl.innerText = 'Top (remote):
' + data.map((s,i)=>`${i+1}. ${s.name} - ${s.score}`).join('
'); } }catch(err){ console.warn('fetch remote',err); } }
  document.getElementById('saveBtn').addEventListener('click', async ()=>{ const name = (document.getElementById('name').value || '익명').slice(0,10); saveLocalScore(name, score); await saveRemoteScore(name, score); alert('저장 완료'); });

  // ---------- Multiplayer: players table sync ----------
  // Expected players table schema:
  // create table players ( id uuid primary key default uuid_generate_v4(), name text unique, x float, y float, speed float, updated_at timestamptz default now() );

  let updateTimer = null;
  async function createOrUpdatePlayer(){
    if(!localName) return;
    try{
      await supabaseClient.from('players').upsert([{ id: localId, name: localName, x: player.x, y: player.y, speed: player.speed }]);
    }catch(e){ console.warn('player upsert err',e); }
  }

  // subscribe to players table changes
  const subscription = supabaseClient.channel('public:players')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'players' }, payload => {
      const ev = payload.eventType; const row = payload.new || payload.old;
      if(ev === 'INSERT' || ev === 'UPDATE'){
        // assign color deterministically
        const idx = Math.abs(hashCode(row.id || row.name)) % colors.length; const color = colors[idx];
        remotePlayers.set(row.id, { name: row.name, x: row.x, y: row.y, speed: row.speed, updated_at: row.updated_at, w:24, h:36, color });
      }else if(ev === 'DELETE'){
        remotePlayers.delete(row.id);
      }
    })
    .subscribe();

  function hashCode(str){ let h=0; for(let i=0;i<str.length;i++){ h = (h<<5)-h + str.charCodeAt(i); h |= 0; } return h; }

  // periodically push local position to DB
  function startPositionUpdates(){
    if(updateTimer) clearInterval(updateTimer);
    updateTimer = setInterval(()=>{
      createOrUpdatePlayer();
    }, 300); // 300ms default
  }

  // remove player on unload
  async function removePlayer(){ try{ await supabaseClient.from('players').delete().eq('id', localId); }catch(e){ console.warn('remove player err',e); } }
  window.addEventListener('beforeunload', ()=>{ removePlayer(); });

  // when user sets name
  const modal = document.getElementById('modal');
  const startBtn = document.getElementById('startBtn');
  const startName = document.getElementById('startName');
  const nameInput = document.getElementById('name');
  if(localName){ modal.style.display='none'; nameInput.value = localName; initMultiplayer(); }
  startBtn.addEventListener('click', ()=>{ const v = (startName.value || '').trim() || ('player-'+Math.floor(Math.random()*9000+1000)); localName = v.slice(0,12); localStorage.setItem('pixel-racer-name', localName); nameInput.value = localName; modal.style.display='none'; initMultiplayer(); });

  function initMultiplayer(){
    // initial upsert and fetch existing players
    createOrUpdatePlayer();
    fetchTopRemote();
    // fetch current players to render immediately
    supabaseClient.from('players').select('*').then(res=>{ if(res?.data){ for(const r of res.data){ const idx = Math.abs(hashCode(r.id || r.name)) % colors.length; remotePlayers.set(r.id, { name:r.name, x:r.x, y:r.y, speed:r.speed, updated_at:r.updated_at, w:24,h:36, color: colors[idx] }); } } }).catch(e=>console.warn(e));
    startPositionUpdates();
  }

  // update remote position more frequently when game updates (also called each frame)
  // We'll throttle to avoid too many writes: createOrUpdatePlayer already used by interval

  // Helpful console note
  console.log('Pixel Racer Multiplayer ready — nickname set:', localName || '(waiting)');

  </script>
</body>
  </html>
  
