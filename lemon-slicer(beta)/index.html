<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>레몬 게임 🍋</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #fef9c3;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: sans-serif;
      user-select: none;
    }
    canvas {
      background: #fff3b0;
      border: 5px solid #facc15;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    #startBtn {
      position: absolute;
      padding: 12px 28px;
      font-size: 20px;
      background: #facc15;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: 0.2s;
    }
    #startBtn:hover {
      background: #fde047;
    }
  </style>
</head>
<body>
  <button id="startBtn">🍋 게임 시작</button>
  <canvas id="gameCanvas" width="400" height="600"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const startBtn = document.getElementById("startBtn");

    let gameRunning = false;
    let lemons = [];
    let droppingLemon = null;
    let mouseX = canvas.width / 2;

    const lemonImages = [
      { color: "#fde047", radius: 15 },
      { color: "#facc15", radius: 25 },
      { color: "#eab308", radius: 40 },
      { color: "#ca8a04", radius: 60 }
    ];

    class Lemon {
      constructor(x, y, level) {
        this.x = x;
        this.y = y;
        this.level = level;
        this.r = lemonImages[level].radius;
        this.color = lemonImages[level].color;
        this.dy = 0;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.strokeStyle = "#fcd34d";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      update() {
        this.dy += 0.4;
        this.y += this.dy;
        if (this.y + this.r > canvas.height) {
          this.y = canvas.height - this.r;
          this.dy *= -0.5;
        }
      }
    }

    function resetGame() {
      lemons = [];
      droppingLemon = null;
      gameRunning = true;
      startBtn.style.display = "none";
      spawnNewLemon();
      requestAnimationFrame(loop);
    }

    function spawnNewLemon() {
      droppingLemon = new Lemon(mouseX, 50, 0);
    }

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      if (droppingLemon) droppingLemon.x = mouseX;
    });

    canvas.addEventListener("click", () => {
      if (!gameRunning) return;
      if (droppingLemon) {
        lemons.push(droppingLemon);
        droppingLemon = null;
        setTimeout(spawnNewLemon, 500);
      }
    });

    function checkCollision(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const dist = Math.hypot(dx, dy);
      return dist < a.r + b.r;
    }

    function loop() {
      if (!gameRunning) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let l of lemons) {
        l.update();
        l.draw();
      }

      // 병합 처리
      for (let i = 0; i < lemons.length; i++) {
        for (let j = i + 1; j < lemons.length; j++) {
          let a = lemons[i];
          let b = lemons[j];
          if (a.level === b.level && checkCollision(a, b)) {
            const nx = (a.x + b.x) / 2;
            const ny = (a.y + b.y) / 2;
            lemons.splice(j, 1);
            lemons.splice(i, 1);
            if (a.level < lemonImages.length - 1) {
              lemons.push(new Lemon(nx, ny, a.level + 1));
            }
            break;
          }
        }
      }

      if (droppingLemon) {
        droppingLemon.draw();
      }

      requestAnimationFrame(loop);
    }

    startBtn.addEventListener("click", resetGame);
  </script>
</body>
</html>
